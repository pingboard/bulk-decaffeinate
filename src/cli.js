import 'babel-polyfill';
import commander from 'commander';

import check from './check';
import clean from './clean';
import resolveConfig from './config/resolveConfig';
import convert from './convert';
import land from './land';
import modernizeJS from './modernizeJS';
import CLIError from './util/CLIError';
import viewErrors from './viewErrors';

export default function () {
  let command = null;
  commander
    .arguments('<command>')
    .description(`Run decaffeinate on a set of files.

  Commands:
    check: Try decaffeinate on the specified files and generate a report of which files can be
           converted. By default, all .coffee files in the current directory are used.
    convert: Run decaffeinate on the specified files and generate git commits for the transition.
    view-errors: Open failures from the most recent run in an online repl.
    clean: Delete all files ending with .original.coffee in the current working directory or any
           of its subdirectories.
    land: Create a merge commit with all commits generated by bulk-decaffeinate.`)
    .action(commandArg => command = commandArg)
    .option('-c, --config [path]',
      `The config file to use. This arg may be specified multiple
                              times. If unspecified, files like bulk-decaffeinate.config.js will
                              be discovered and used.`,
      (arg, args) => {args.push(arg); return args;}, [])
    .option('-f, --file [path]',
      `An absolute or relative path to decaffeinate. This arg may be
                              specified multiple times.`,
      (arg, args) => {args.push(arg); return args;}, [])
    .option('-p, --path-file [path]',
      `A file containing the paths of .coffee files to decaffeinate, one
                              path per line. Paths can be either absolute or relative to the
                              current working directory.`)
    .option('-d, --dir [path]',
      `A directory containing files to decaffeinate. All .coffee files in
                              any subdirectory of this directory are considered for decaffeinate.`)
    .option('--use-js-modules',
      `If specified, decaffeinate will convert the code to use import/export
                              syntax and a follow-up fix-imports step will correct any imports
                              across the codebase.`)
    .option('--land-base [revision]',
      `The git revision to use as the base commit when running the "land"
                              command. If none is specified, bulk-decaffeinate tries to use the
                              first auto-generated commit in recent history.`)
    .option('--num-workers [number]',
      `The number of workers to use for parallel operations.`)
    .option('--skip-verify',
      `If specified, skips the initial verification step when running the
                              "convert" command.`)
    .option('--decaffeinate-path [path]',
      `The path to the decaffeinate binary. If none is specified, it will
                              be automatically discovered from node_modules and then from the
                              PATH.`)
    .option('--jscodeshift-path [path]',
      `The path to the jscodeshift binary. If none is specified, it will be
                              automatically discovered from node_modules and then from the PATH.`)
    .option('--eslint-path [path]',
      `The path to the eslint binary. If none is specified, it will be
                              automatically discovered from node_modules and then from the PATH.`)
    .option('--prettier-path [path]',
      `The path to the prettier binary. If none is specified, it will be
                              automatically discovered from node_modules and then from the PATH.`)
    .option('--allow-invalid-constructors',
      `Deprecated; decaffeinate now allows invalid constructors by default.`)
    .parse(process.argv);

  runCommand(command);
}

async function runCommand(command) {
  try {
    if (command === 'check') {
      let config = await resolveConfig(commander);
      await check(config);
    } else if (command === 'convert') {
      let config = await resolveConfig(commander, {needsJscodeshift: true, needsEslint: true, needsPrettier: true});
      await convert(config);
    } else if (command === 'modernize-js') {
      let config = await resolveConfig(commander, {needsJscodeshift: true, needsEslint: true, needsPrettier: true});
      await modernizeJS(config);
    } else if (command === 'view-errors') {
      await viewErrors();
    } else if (command === 'clean') {
      await clean();
    } else if (command === 'land') {
      let config = await resolveConfig(commander);
      await land(config);
    } else {
      commander.outputHelp();
    }
  } catch (e) {
    process.exitCode = 1;
    console.error(CLIError.formatError(e));
  }
}
